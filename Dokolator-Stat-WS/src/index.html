<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dokolator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
        }
        h1 {
            color: #0056b3;
            text-align: center;
            margin-bottom: 10px;
        }
        h2 {
            color: #0056b3;
            margin-top: 30px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        #newGameDayButton {
            display: block;
            width: auto;
            margin: 0 auto 25px auto;
            padding: 10px 15px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        #newGameDayButton:hover {
            background-color: #c82333;
        }
        #currentDate {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 1.1em;
            color: #555;
        }
        .input-section, .output-section, .abrechnung-section, .chart-section {
            margin-bottom: 30px;
        }
        .abrechnung-section, .chart-section {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #ccc;
        }

        .player-count-selection, .game-selection-group {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .player-count-selection label, .game-selection-group label, .abrechnung-section label {
            margin-right: 10px;
            font-weight: bold;
        }
         .abrechnung-section input[type="number"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 80px;
        }
        .abrechnung-section div {
            margin-bottom: 10px;
        }


        .game-value-radios {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
            justify-content: flex-start;
            align-items: center;
        }
        .game-value-radios div { display: flex; align-items: center; }
        .game-value-radios input[type="radio"] { margin-right: 5px; }
        .game-value-radios label { font-weight: normal; margin-right: 0; }

        .bock-trigger-section { margin-top: 15px; padding-top: 10px; border-top: 1px solid #e0e0e0; }
        .bock-trigger-section h4 { margin-bottom: 8px; }
        .bock-trigger-section div { display: flex; align-items: center; }
        .bock-trigger-section input[type="checkbox"] { margin-right: 8px; }
        .bock-trigger-section label { font-weight: normal; }

        .game-value-input { margin-top: 15px; display: flex; align-items: center; gap: 10px; }
        .game-value-input input[type="number"] { padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 80px; }

        .players-and-roles-container { background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin-bottom: 20px; overflow-x: auto; }
        .player-role-row { display: flex; flex-wrap: nowrap; gap: 20px; padding-bottom: 10px; }
        .player-column { flex: 0 0 180px; min-width: 180px; border-right: 1px solid #eee; padding-right: 20px; box-sizing: border-box; }
        .player-column:last-child { border-right: none; }
        .player-column label { display: block; margin-bottom: 5px; font-weight: bold; }
        .player-column input[type="text"] { width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; margin-bottom: 15px; }
        .role-radio-group { margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px; }
        .role-radio-group h4 { margin-top: 0; margin-bottom: 8px; font-size: 0.9em; color: #555; }
        .role-radio-group .radio-option { display: flex; align-items: center; margin-bottom: 5px; }
        .role-radio-group input[type="radio"] { margin-right: 5px; }
        .role-radio-group label { font-weight: normal; cursor: pointer; margin-bottom: 0; }

        button#submitGameButton {
            display: block; width: 100%; padding: 12px 20px; background-color: #007bff;
            color: white; border: none; border-radius: 5px; font-size: 18px;
            cursor: pointer; margin-top: 30px; transition: background-color 0.3s ease;
        }
        button#submitGameButton:hover { background-color: #0056b3; }
        button.edit-btn {
            padding: 5px 10px; font-size: 0.9em; background-color: #ffc107; color: #333;
            border: none; border-radius: 3px; cursor: pointer; transition: background-color 0.2s ease;
        }
        button.edit-btn:hover { background-color: #e0a800; }

        #outputTable, #abrechnungTable { width: 100%; border-collapse: collapse; margin-top: 20px; }
        #outputTable th, #outputTable td, #abrechnungTable th, #abrechnungTable td {
            border: 1px solid #ddd; padding: 10px; text-align: left;
        }
        #outputTable th, #abrechnungTable th { background-color: #f2f2f2; font-weight: bold; }
        #outputTable th:last-child, #outputTable td:last-child { text-align: center; width: 60px; }
        #abrechnungTable td:not(:first-child), #abrechnungTable th:not(:first-child) { text-align: right; }

        .out-of-round { color: #999; font-style: italic; background-color: #f8f9fa; }
        .re-partei { background-color: #e6f7ff; }
        .kontra-partei { background-color: #fff0e6; }
        .solo-player { background-color: #ffe6e6; }
        .bock-trigger-round {
            background-color: #ffebee !important;
        }
        #errorMessage { color: red; margin-top: 15px; font-weight: bold; display: none; }
        /* .negative-score { color: red; } */ /* Nicht mehr benötigt für Abrechnung, da Beträge positiv angezeigt werden */
    </style>
</head>
<body>
    <div class="container">
        <h1>Doppelkopf Auswertung</h1>
        <button id="newGameDayButton">Neuen Spieltag starten (Daten löschen)</button>
        <div id="currentDate"></div>

        <div class="input-section">
            <h2>Spielerfassung</h2>
            <form id="playerForm">
                <div class="player-count-selection">
                    <label>Anzahl der Spieler:</label>
                    <input type="radio" id="players4" name="playerCount" value="4">
                    <label for="players4">4 Spieler</label>
                    <input type="radio" id="players5" name="playerCount" value="5" checked>
                    <label for="players5">5 Spieler</label>
                </div>
                <div class="players-and-roles-container">
                    <label style="margin-bottom: 10px; display: block;">Spieler-Namen und Rollen zuweisen:</label>
                    <div id="playerRoleRow" class="player-role-row"></div>
                </div>
                <div class="game-selection-group">
                    <h3>Spielinformationen</h3>
                    <div class="game-value-section">
                        <h4>Spielwert:</h4>
                        <div class="game-value-radios">
                            <div class="radio-option"><input type="radio" id="value1" name="gameValueRadio" value="1"><label for="value1">1</label></div>
                            <div class="radio-option"><input type="radio" id="value2" name="gameValueRadio" value="2"><label for="value2">2</label></div>
                            <div class="radio-option"><input type="radio" id="value3" name="gameValueRadio" value="3"><label for="value3">3</label></div>
                            <div class="radio-option"><input type="radio" id="value4" name="gameValueRadio" value="4"><label for="value4">4</label></div>
                            <div class="radio-option"><input type="radio" id="value5" name="gameValueRadio" value="5"><label for="value5">5</label></div>
                            <div class="radio-option"><input type="radio" id="value6" name="gameValueRadio" value="6"><label for="value6">6</label></div>
                            <div class="radio-option"><input type="radio" id="value7" name="gameValueRadio" value="7"><label for="value7">7</label></div>
                            <div class="radio-option"><input type="radio" id="value8" name="gameValueRadio" value="8"><label for="value8">8</label></div>
                            <div class="radio-option"><input type="radio" id="value0" name="gameValueRadio" value="0"><label for="value0">0</label></div>
                            <div class="radio-option"><input type="radio" id="valueNeg1" name="gameValueRadio" value="-1"><label for="valueNeg1">-1</label></div>
                            <div class="radio-option"><input type="radio" id="valueNeg2" name="gameValueRadio" value="-2"><label for="valueNeg2">-2</label></div>
                            <div class="radio-option"><input type="radio" id="valueNeg3" name="gameValueRadio" value="-3"><label for="valueNeg3">-3</label></div>
                            <div class="radio-option"><input type="radio" id="valueNeg4" name="gameValueRadio" value="-4"><label for="valueNeg4">-4</label></div>
                            <div class="radio-option"><input type="radio" id="valueNeg5" name="gameValueRadio" value="-5"><label for="valueNeg5">-5</label></div>
                            <div class="radio-option"><input type="radio" id="valueNeg6" name="gameValueRadio" value="-6"><label for="valueNeg6">-6</label></div>
                            <div class="radio-option"><input type="radio" id="valueNeg7" name="gameValueRadio" value="-7"><label for="valueNeg7">-7</label></div>
                            <div class="radio-option"><input type="radio" id="valueNeg8" name="gameValueRadio" value="-8"><label for="valueNeg8">-8</label></div>
                        </div>
                        <div class="game-value-input">
                            <label for="customGameValue">Oder eigener Wert:</label>
                            <input type="number" id="customGameValue" name="customGameValue">
                        </div>
                    </div>
                    <div class="bock-trigger-section">
                        <h4>Neue Bockrunde(n) auslösen?</h4>
                        <div>
                            <input type="checkbox" id="triggerNewBockRound" name="triggerNewBockRound">
                            <label for="triggerNewBockRound">Ja, für dieses Spiel auslösen</label>
                        </div>
                    </div>
                </div>
                <button type="submit" id="submitGameButton">Spielrunde erfassen & Teams bilden</button>
                <div id="errorMessage"></div>
            </form>
        </div>

        <div class="output-section" style="display: none;">
            <h2>Spielverlauf & Punktestand</h2>
            <table id="outputTable">
                <thead>
                    <tr>
                        <th>Spiel #</th>
                        <th>Spielwert</th>
                        <th>Bock</th>
                        </tr>
                </thead>
                <tbody id="outputTableBody"></tbody>
            </table>
        </div>

        <div class="abrechnung-section">
            <h2>Tagesabrechnung</h2>
            <div>
                <label for="startgeldInput">Startgeld p.P. (€):</label>
                <input type="number" id="startgeldInput" value="10.00" step="0.01" min="0">
            </div>
            <div>
                <label for="punktwertInput">Punktwert (€):</label>
                <input type="number" id="punktwertInput" value="0.05" step="0.001" min="0">
            </div>
            <div id="abrechnungOutput" style="margin-top: 20px; display: none;">
                <table id="abrechnungTable">
                    <thead></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div class="chart-section" style="margin-top: 40px; padding-top: 20px; border-top: 2px solid #ccc; display: none;">
            <h2>Punkteverlauf</h2>
            <div class="chart-wrapper" style="position: relative; height: 450px; width: 100%;">
                <canvas id="scoreChart"></canvas> </div>
        </div>
    </div>

    <script>
        const playerCountRadios = document.querySelectorAll('input[name="playerCount"]');
        const playerRoleRow = document.getElementById('playerRoleRow');
        const playerForm = document.getElementById('playerForm');
        const outputSection = document.querySelector('.output-section');
        const outputTableBody = document.getElementById('outputTableBody');
        const errorMessageDiv = document.getElementById('errorMessage');
        const gameValueRadios = document.querySelectorAll('input[name="gameValueRadio"]');
        const customGameValueInput = document.getElementById('customGameValue');
        const outputTable = document.getElementById('outputTable');
        const currentDateDiv = document.getElementById('currentDate');
        const submitGameButton = document.getElementById('submitGameButton');
        const newGameDayButton = document.getElementById('newGameDayButton');
        const startgeldInput = document.getElementById('startgeldInput');
        const punktwertInput = document.getElementById('punktwertInput');
        const abrechnungOutputDiv = document.getElementById('abrechnungOutput');
        const abrechnungTable = document.getElementById('abrechnungTable');
        const chartSectionDiv = document.querySelector('.chart-section');
        const scoreChartCanvas = document.getElementById('scoreChart');

        let totalScores = {};
        let currentPlayerNamesOrder = [];
        let currentDealerIndex = -1;
        let bockRoundsActive = 0;
        let bockGamesPlayedInCurrentStreak = 0;
        let totalBockGamesInCurrentStreak = 0;
        let allGamesData = [];
        let editingGameIndex = -1;
        let myScoreChart = null;

        const DOKO_STORAGE_KEY = 'doppelkopfAuswertungSession_vFinalCompletePlus_v5';

        const roleDisplayNames = {
            re: 'R', kontra: 'K', hochzeit: 'H', solo: 'S', geber: 'G'
        };

        function displayCurrentDate() {
            const now = new Date();
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            currentDateDiv.textContent = now.toLocaleDateString('de-DE', options);
        }

        function createPlayerColumns(count, playerNamesFromGameToEdit = null) {
            const existingPlayerNamesMap = new Map();
            if (playerNamesFromGameToEdit) {
                playerNamesFromGameToEdit.forEach((player, index) => {
                    if (player.name) existingPlayerNamesMap.set(`player${index + 1}`, player.name);
                });
            } else {
                for (let i = 0; i < Math.max(currentPlayerNamesOrder.length, 5); i++) {
                    const inputField = document.getElementById(`player${i + 1}`);
                    if (inputField && inputField.value.trim() !== '') {
                        existingPlayerNamesMap.set(`player${i + 1}`, inputField.value.trim());
                    } else if (i < currentPlayerNamesOrder.length && currentPlayerNamesOrder[i] && currentPlayerNamesOrder[i].trim() !== '') {
                        existingPlayerNamesMap.set(`player${i + 1}`, currentPlayerNamesOrder[i].trim());
                    }
                }
            }

            playerRoleRow.innerHTML = '';
            const newPlayerNamesForCurrentOrder = [];
            for (let i = 0; i < count; i++) {
                let fieldPlayerName = '';
                if (playerNamesFromGameToEdit && i < playerNamesFromGameToEdit.length) {
                    fieldPlayerName = playerNamesFromGameToEdit[i].name || '';
                } else {
                     fieldPlayerName = existingPlayerNamesMap.get(`player${i + 1}`) ||
                                       (i < currentPlayerNamesOrder.length ? currentPlayerNamesOrder[i] : '') ||
                                       '';
                }
                newPlayerNamesForCurrentOrder.push(fieldPlayerName);


                const playerColumn = document.createElement('div');
                playerColumn.classList.add('player-column');
                playerColumn.innerHTML = `
                    <label for="player${i + 1}">Spieler ${i + 1}:</label>
                    <input type="text" id="player${i + 1}" name="player${i + 1}" value="${fieldPlayerName}" ${i < Math.min(count, 4) ? 'required' : ''}>
                    <div class="role-radio-group">
                        <h4>Rolle:</h4>
                        <div class="radio-option"><input type="radio" id="role${i + 1}-geber" name="rolePlayer${i + 1}" value="geber"><label for="role${i + 1}-geber">Geber</label></div>
                        <div class="radio-option"><input type="radio" id="role${i + 1}-re" name="rolePlayer${i + 1}" value="re"><label for="role${i + 1}-re">Re</label></div>
                        <div class="radio-option"><input type="radio" id="role${i + 1}-hochzeit" name="rolePlayer${i + 1}" value="hochzeit"><label for="role${i + 1}-hochzeit">Hochzeit</label></div>
                        <div class="radio-option"><input type="radio" id="role${i + 1}-solo" name="rolePlayer${i + 1}" value="solo"><label for="role${i + 1}-solo">Solo</label></div>
                    </div>`;
                playerRoleRow.appendChild(playerColumn);
            }

            if (!playerNamesFromGameToEdit) {
                 currentPlayerNamesOrder = newPlayerNamesForCurrentOrder.slice(0, count);
            }


            playerRoleRow.querySelectorAll('input[type="radio"][name^="rolePlayer"]').forEach(radio => {
                radio.addEventListener('change', (event) => {
                    const currentRadio = event.target;
                    if (currentRadio.value === 'geber' && currentRadio.checked) {
                        playerRoleRow.querySelectorAll('input[type="radio"][value="geber"]').forEach(otherGeberRadio => {
                            if (otherGeberRadio !== currentRadio) otherGeberRadio.checked = false;
                        });
                        for (let k = 0; k < count; k++) {
                            if (document.getElementById(`role${k + 1}-geber`) === currentRadio) {
                                currentDealerIndex = k;
                                break;
                            }
                        }
                    }
                    validateRoles();
                });
            });

            playerRoleRow.querySelectorAll('input[type="text"][name^="player"]').forEach((input, index) => {
                input.addEventListener('input', (event) => {
                    try {
                        const newName = event.target.value.trim();
                        const oldName = (index < currentPlayerNamesOrder.length) ? currentPlayerNamesOrder[index] : "";

                        if (index < count) {
                            while(currentPlayerNamesOrder.length <= index || currentPlayerNamesOrder.length < count) {
                                currentPlayerNamesOrder.push("");
                            }
                            currentPlayerNamesOrder = currentPlayerNamesOrder.slice(0, count);
                            currentPlayerNamesOrder[index] = newName;
                        } else {
                            console.error("Input-Event für einen Index außerhalb der erwarteten Spieleranzahl:", index, count);
                            return;
                        }

                        if (oldName === newName) return;

                        if (editingGameIndex === -1) {
                            if (oldName && oldName.trim() !== '' && totalScores.hasOwnProperty(oldName)) {
                                if (newName && !totalScores.hasOwnProperty(newName)) {
                                    totalScores[newName] = totalScores[oldName];
                                }
                                if (oldName.toLowerCase() !== newName.toLowerCase() || !newName) {
                                    delete totalScores[oldName];
                                }
                            }
                            if (newName && !totalScores.hasOwnProperty(newName)) {
                                totalScores[newName] = 0;
                            }
                        }

                        updateOutputTableHeader();
                        validateRoles();

                        const geberRadioChecked = document.querySelector('input[name^="rolePlayer"][value="geber"]:checked');
                        if (geberRadioChecked) {
                            const radioName = geberRadioChecked.name;
                            const fieldNumber = parseInt(radioName.replace('rolePlayer', ''), 10);
                            if (!isNaN(fieldNumber)) {
                                currentDealerIndex = fieldNumber - 1;
                            }
                        } else {
                            currentDealerIndex = -1;
                        }
                    } catch (e) {
                        console.error("Fehler im Namens-Input-Event-Listener:", e);
                    }
                });
            });

            if (editingGameIndex === -1 ) {
                currentPlayerNamesOrder.forEach(name => {
                    if (name && name.trim() && !totalScores.hasOwnProperty(name.trim())) {
                        totalScores[name.trim()] = 0;
                    }
                });
            }


            if (editingGameIndex === -1 && !playerNamesFromGameToEdit) {
                setNextDealerAutomatically();
            }
            updateOutputTableHeader();
        }

        function updateOutputTableHeader() {
            let headRow = outputTable.querySelector('thead tr');
            if (!headRow) {
                const thead = outputTable.tHead || outputTable.createTHead();
                headRow = thead.insertRow();
                headRow.insertCell().textContent = 'Spiel #';
                headRow.insertCell().textContent = 'Spielwert';
                headRow.insertCell().textContent = 'Bock';
            }
            while (headRow.children.length > 3) {
                headRow.removeChild(headRow.lastChild);
            }

            let namesForHeader = currentPlayerNamesOrder.filter(name => name && name.trim());
            if(namesForHeader.length === 0){
                const numPlayersInForm = parseInt(document.querySelector('input[name="playerCount"]:checked').value);
                for (let i = 0; i < numPlayersInForm; i++) {
                    const playerInput = document.getElementById(`player${i + 1}`);
                    if (playerInput && playerInput.value.trim()) {
                        namesForHeader.push(playerInput.value.trim());
                    }
                }
            }


            namesForHeader.forEach(name => {
                const th = document.createElement('th');
                th.textContent = name;
                headRow.appendChild(th);
            });

            const aktionTh = document.createElement('th');
            aktionTh.textContent = 'Aktion';
            headRow.appendChild(aktionTh);
        }


        function setNextDealerAutomatically(lastDealerNameFromGame = null) {
            const numPlayers = parseInt(document.querySelector('input[name="playerCount"]:checked').value);
            const activePlayerNamesInDOM = [];
            for (let i = 0; i < numPlayers; i++) {
                const playerInput = document.getElementById(`player${i + 1}`);
                if (playerInput && playerInput.value.trim()) {
                    activePlayerNamesInDOM.push(playerInput.value.trim());
                }
            }

            playerRoleRow.querySelectorAll('input[type="radio"][value="geber"]').forEach(radio => radio.checked = false);

            if (activePlayerNamesInDOM.length === 0) {
                currentDealerIndex = -1;
                validateRoles();
                return;
            }

            let lastDealerIdxInActiveList = -1;

            if (lastDealerNameFromGame) {
                lastDealerIdxInActiveList = activePlayerNamesInDOM.indexOf(lastDealerNameFromGame);
            } else if (currentDealerIndex !== -1 && currentDealerIndex < currentPlayerNamesOrder.length && currentPlayerNamesOrder[currentDealerIndex]) {
                const dealerNameToFind = currentPlayerNamesOrder[currentDealerIndex];
                lastDealerIdxInActiveList = activePlayerNamesInDOM.indexOf(dealerNameToFind);
            }


            let nextDealerIdxInActiveList;
            if (lastDealerIdxInActiveList === -1 || lastDealerIdxInActiveList >= activePlayerNamesInDOM.length) {
                nextDealerIdxInActiveList = 0;
            } else {
                nextDealerIdxInActiveList = (lastDealerIdxInActiveList + 1) % activePlayerNamesInDOM.length;
            }

            const nextDealerName = activePlayerNamesInDOM[nextDealerIdxInActiveList];
            currentDealerIndex = -1;

            for (let i = 0; i < numPlayers; i++) {
                const playerInput = document.getElementById(`player${i + 1}`);
                if (playerInput && playerInput.value.trim() === nextDealerName) {
                    currentDealerIndex = i;
                    const dealerRadio = document.getElementById(`role${i + 1}-geber`);
                    if (dealerRadio) dealerRadio.checked = true;
                    break;
                }
            }
            validateRoles();
        }

        function validateRoles() {
            errorMessageDiv.style.display = 'none'; errorMessageDiv.textContent = '';
            const selectedPlayerCount = document.querySelector('input[name="playerCount"]:checked').value;
            const numPlayers = parseInt(selectedPlayerCount);
            const rolesAssigned = { geber: [], re: [], hochzeit: [], solo: [] };
            let geberPlayerNameFromRadio = null;
            let namedPlayerInputsInDom = [];

            for (let i = 1; i <= numPlayers; i++) {
                const playerNameInput = document.getElementById(`player${i}`);
                const playerName = playerNameInput ? playerNameInput.value.trim() : '';
                if (playerName) namedPlayerInputsInDom.push(playerName);

                const selectedRoleRadio = document.querySelector(`input[name="rolePlayer${i}"]:checked`);

                if (i <= Math.min(numPlayers, 4) && playerName === '') {
                    errorMessageDiv.textContent = `Spieler ${i} benötigt einen Namen.`; errorMessageDiv.style.display = 'block'; return false;
                }
                if (selectedRoleRadio) {
                    const roleValue = selectedRoleRadio.value;
                    if (playerName) {
                        if (['re', 'hochzeit', 'solo'].includes(roleValue)) rolesAssigned[roleValue].push(playerName);
                        if (roleValue === 'geber') {
                            rolesAssigned.geber.push(playerName);
                        }
                    } else if (roleValue === 'geber' && selectedRoleRadio.checked) {
                        errorMessageDiv.textContent = `Der als Geber ausgewählte Spieler (Spieler ${i}) muss einen Namen haben.`; errorMessageDiv.style.display = 'block'; return false;
                    }
                }
            }

            if (namedPlayerInputsInDom.length < Math.min(numPlayers, 4) && numPlayers >=4 ) {
                errorMessageDiv.textContent = `Es müssen mindestens ${Math.min(numPlayers, 4)} Spieler einen Namen haben.`; errorMessageDiv.style.display = 'block'; return false;
            }

            const actualNamedGeber = rolesAssigned.geber.filter(g => g && g.trim());
            if (namedPlayerInputsInDom.length > 0 && actualNamedGeber.length === 0) {
                 errorMessageDiv.textContent = 'Es muss ein Spieler als "Geber" ausgewählt sein und einen Namen haben.'; errorMessageDiv.style.display = 'block'; return false;
            }
            if (actualNamedGeber.length > 1) {
                errorMessageDiv.textContent = 'Es darf nur ein Spieler als "Geber" ausgewählt sein.'; errorMessageDiv.style.display = 'block'; return false;
            }
            if(actualNamedGeber.length === 1) geberPlayerNameFromRadio = actualNamedGeber[0];


            const currentGeber = geberPlayerNameFromRadio;
            const isFivePlayers = numPlayers === 5;

            let determinedGameType = 'normal';
            const validSoloPlayers = rolesAssigned.solo.filter(s => s && s.trim());
            const validRePlayers = rolesAssigned.re.filter(r => r && r.trim());
            const validHochzeitPlayers = rolesAssigned.hochzeit.filter(h => h && h.trim());

            if (validSoloPlayers.length > 0) determinedGameType = 'solo';
            else if (validHochzeitPlayers.length > 0) determinedGameType = 'hochzeit';

            const activePlayerNamesForValidation = namedPlayerInputsInDom.filter(name => !(isFivePlayers && name === currentGeber));
            if (activePlayerNamesForValidation.length < 4 && numPlayers >= 4 && namedPlayerInputsInDom.length >=4 ) {
                errorMessageDiv.textContent = `Mind. 4 aktive Spieler benötigt (aktuell ${activePlayerNamesForValidation.length}). Geber bei 5 Spielern setzt aus.`; errorMessageDiv.style.display = 'block'; return false;
            }


            if (determinedGameType === 'solo') {
                if (validSoloPlayers.length !== 1) { errorMessageDiv.textContent = 'Solo: Genau 1 Solo-Spieler.'; errorMessageDiv.style.display = 'block'; return false; }
                if (validRePlayers.length > 0 || validHochzeitPlayers.length > 0) { errorMessageDiv.textContent = 'Solo: Keine Re/Hochzeit-Spieler.'; errorMessageDiv.style.display = 'block'; return false; }
                if (validSoloPlayers.length > 0 && !activePlayerNamesForValidation.includes(validSoloPlayers[0])) {
                    errorMessageDiv.textContent = 'Solo-Spieler muss aktiv sein (kann bei 5 Spielern nicht der Geber sein).'; errorMessageDiv.style.display = 'block'; return false;
                }
            } else if (determinedGameType === 'hochzeit') {
                if (validHochzeitPlayers.length !== 1) { errorMessageDiv.textContent = 'Hochzeit: Genau 1 Hochzeit-Spieler.'; errorMessageDiv.style.display = 'block'; return false; }
                if (validRePlayers.length > 1) { errorMessageDiv.textContent = 'Hochzeit: Max. 1 Re-Partner.'; errorMessageDiv.style.display = 'block'; return false; }
                if (validRePlayers.length === 1 && validHochzeitPlayers[0] === validRePlayers[0]) { errorMessageDiv.textContent = 'Hochzeit: Spieler kann nicht eigener Partner sein.'; errorMessageDiv.style.display = 'block'; return false; }
                if (validHochzeitPlayers.length > 0 && !activePlayerNamesForValidation.includes(validHochzeitPlayers[0])) {
                     errorMessageDiv.textContent = 'Hochzeit-Spieler muss aktiv sein (kann bei 5 Spielern nicht der Geber sein).'; errorMessageDiv.style.display = 'block'; return false;
                }
                if (validRePlayers.length === 1 && !activePlayerNamesForValidation.includes(validRePlayers[0])) {
                     errorMessageDiv.textContent = 'Hochzeit-Partner muss aktiv sein (kann bei 5 Spielern nicht der Geber sein).'; errorMessageDiv.style.display = 'block'; return false;
                }
            } else { // 'normal'
                if (validRePlayers.length !== 2) { errorMessageDiv.textContent = 'Normal: 2 Re-Spieler benötigt.'; errorMessageDiv.style.display = 'block'; return false; }
                 if (!validRePlayers.every(rePlayer => activePlayerNamesForValidation.includes(rePlayer))) {
                     errorMessageDiv.textContent = 'Re-Spieler müssen aktive Spieler sein (können bei 5 Spielern nicht der Geber sein).'; errorMessageDiv.style.display = 'block'; return false;
                 }
            }

            if (determinedGameType !== 'solo' && determinedGameType !== 'hochzeit' && validSoloPlayers.length > 0 ) {
                errorMessageDiv.textContent = 'Kein Solo-Spieler bei Normal/Hochzeit.'; errorMessageDiv.style.display = 'block'; return false;
            }

            const allExplicitRoles = [...validRePlayers, ...validHochzeitPlayers, ...validSoloPlayers];
            if (new Set(allExplicitRoles).size !== allExplicitRoles.length) {
                errorMessageDiv.textContent = 'Spieler können nicht mehrere Rollen (Re, H, Solo) haben.'; errorMessageDiv.style.display = 'block'; return false;
            }
            return true;
        }


        function calculateSoloScores(soloPlayerName, activePlayers, effectiveValue) {
            const scores = {}; activePlayers.forEach(p => scores[p] = 0);
            if (activePlayers.includes(soloPlayerName)) {
                const kontraPlayers = activePlayers.filter(p => p !== soloPlayerName);
                scores[soloPlayerName] = effectiveValue * kontraPlayers.length;
                kontraPlayers.forEach(player => scores[player] = -effectiveValue);
            } return scores;
        }

        function calculateReKontraScores(rePlayerNames, activePlayers, effectiveValue) {
            const scores = {}; activePlayers.forEach(p => scores[p] = 0);
            const actualRePlayersInRound = rePlayerNames.filter(p => activePlayers.includes(p));
            const kontraPlayersInRound = activePlayers.filter(p => !actualRePlayersInRound.includes(p));
            actualRePlayersInRound.forEach(player => scores[player] = effectiveValue);
            kontraPlayersInRound.forEach(player => scores[player] = -effectiveValue);
            return scores;
        }

        function addGameRowToTable(gameDisplayNum, gameAllGamesDataIndex, displayedGameValueText, bockDisplayTextForCell,
                                  allPlayerNamesInHeaderOrder, rosterForThisRow,
                                  cumulativeScoresSnapshot, gameDetails) {
            let newRow = outputTableBody.insertRow();
            newRow.dataset.allGamesDataIndex = gameAllGamesDataIndex;
            newRow.dataset.displayData = JSON.stringify({
                rosterForThisRow,
                cumulativeTotalScores: { ...cumulativeScoresSnapshot },
                ...gameDetails
            });

            if (gameDetails.triggeredBock) {
                newRow.classList.add('bock-trigger-round');
            }

            newRow.insertCell(0).textContent = gameDisplayNum;
            const spielwertCell = newRow.insertCell(1);
            const numericPartOfSpielwert = parseFloat(displayedGameValueText);
            spielwertCell.innerHTML = `<span class="${!isNaN(numericPartOfSpielwert) && numericPartOfSpielwert < 0 ? 'negative-score' : ''}">${displayedGameValueText}</span>`;
            newRow.insertCell(2).textContent = bockDisplayTextForCell;

            allPlayerNamesInHeaderOrder.forEach(playerName => {
                const currentCumulativeScoreToShow = cumulativeScoresSnapshot[playerName] || 0;
                let cell = newRow.insertCell(); let roleChar = '-'; let classToAdd = '';
                const playerInfo = rosterForThisRow.find(p => p.name === playerName);

                if (playerInfo) {
                    const isActive = gameDetails.activePlayersInThisRow.includes(playerName);
                    if (gameDetails.isFivePlayerGame && playerName === gameDetails.geberName && !isActive) {
                        roleChar = roleDisplayNames.geber; classToAdd = 'out-of-round';
                    } else if (isActive) {
                        roleChar = roleDisplayNames[playerInfo.roleForDisplay] || '?';
                        if ((gameDetails.type === 'solo' && playerName === gameDetails.soloSpieler) ||
                            (gameDetails.type.startsWith('hochzeit') && gameDetails.soloSpieler && playerName === gameDetails.soloSpieler) ||
                            (gameDetails.type === 'hochzeit_phase1' && playerName === gameDetails.soloSpieler) ) {
                            classToAdd = 'solo-player';
                        } else if (((gameDetails.type === 'normal' || gameDetails.type === 'hochzeit_mit_partner') &&
                                    gameDetails.rePartei && gameDetails.rePartei.includes(playerName))) {
                            classToAdd = 're-partei';
                        } else {
                            classToAdd = 'kontra-partei';
                        }
                    } else {
                        roleChar = '⌀'; classToAdd = 'out-of-round';
                    }
                } else if (gameDetails.isFivePlayerGame && playerName === gameDetails.geberName && !gameDetails.activePlayersInThisRow.includes(playerName)) {
                    roleChar = roleDisplayNames.geber; classToAdd = 'out-of-round';
                } else if (!gameDetails.activePlayersInThisRow.includes(playerName) && allPlayerNamesInHeaderOrder.includes(playerName)) {
                     roleChar = '⌀'; classToAdd = 'out-of-round';
                }


                let scoreDisp = currentCumulativeScoreToShow >= 0 ? `+${currentCumulativeScoreToShow}` : `${currentCumulativeScoreToShow}`;
                if (cumulativeScoresSnapshot[playerName] === undefined) {
                    cell.innerHTML = `${roleChar} <span>0</span>`;
                } else {
                    // Beachte: .negative-score hier bezieht sich auf den kumulativen Spielstand, nicht auf den Zahlbetrag in der Abrechnung
                    cell.innerHTML = `${roleChar} <span class="${currentCumulativeScoreToShow < 0 ? 'negative-score' : ''}">${scoreDisp}</span>`;
                }
                if (classToAdd) cell.classList.add(classToAdd);
            });
            const actionCell = newRow.insertCell(); const editBtn = document.createElement('button');
            editBtn.textContent = '✍️'; editBtn.classList.add('edit-btn'); editBtn.title = `Spiel ${gameDisplayNum} bearbeiten`;
            editBtn.onclick = () => startEditGame(gameAllGamesDataIndex); actionCell.appendChild(editBtn);
        }

        function resetFormAndPrepareForNewGame(keepPlayerNames = false) {
            customGameValueInput.value = '';
            gameValueRadios.forEach(radio => radio.checked = false);
            document.getElementById('triggerNewBockRound').checked = false;
            const numPlayersCurrent = parseInt(document.querySelector('input[name="playerCount"]:checked').value);

            for (let i = 1; i <= 5; i++) {
                const roleRadios = document.querySelectorAll(`input[name="rolePlayer${i}"]`);
                roleRadios.forEach(radio => {
                    if (radio.value !== 'geber') radio.checked = false;
                });
                if (!keepPlayerNames) {
                    const nameInput = document.getElementById(`player${i}`);
                    if (nameInput) nameInput.value = '';
                }
            }
            if (!keepPlayerNames) {
                currentPlayerNamesOrder = Array(numPlayersCurrent).fill("");
                updateOutputTableHeader();
                totalScores = {};
            }
            editingGameIndex = -1;
            submitGameButton.textContent = 'Spielrunde erfassen & Teams bilden';
            submitGameButton.style.backgroundColor = '#007bff';
            if(!keepPlayerNames) {
                setNextDealerAutomatically();
            }
            validateRoles();
        }

        function gatherInputsFromForm() {
            const selCount = parseInt(document.querySelector('input[name="playerCount"]:checked').value);
            const playersData = [];
            for (let i = 1; i <= selCount; i++) {
                const nameIn = document.getElementById(`player${i}`);
                const roleRad = document.querySelector(`input[name="rolePlayer${i}"]:checked`);
                playersData.push({ name: nameIn ? nameIn.value.trim() : '', selectedRole: roleRad ? roleRad.value : null });
            }

            let valIn = null; const selValRad = document.querySelector('input[name="gameValueRadio"]:checked');
            if (selValRad) valIn = selValRad.value;
            else if (customGameValueInput.value.trim() !== '') valIn = customGameValueInput.value.trim();

            if (valIn === null || valIn.trim() === '') {
                errorMessageDiv.textContent = 'Spielwert fehlt oder ist ungültig.'; errorMessageDiv.style.display = 'block'; return null;
            }
            const numVal = parseInt(valIn);
            if (isNaN(numVal)) { errorMessageDiv.textContent = 'Ungültiger Spielwert.'; errorMessageDiv.style.display = 'block'; return null; }
            return {
                id: editingGameIndex !== -1 ? allGamesData[editingGameIndex].id : Date.now() + Math.random(),
                playerCount: selCount, players: playersData, gameValue: numVal,
                triggerNewBockRound: document.getElementById('triggerNewBockRound').checked
            };
        }

        playerForm.addEventListener('submit', function(event) {
            event.preventDefault();
            if (!validateRoles()) return;
            const gameInputs = gatherInputsFromForm();
            if (!gameInputs) return;

            const currentNumPlayers = parseInt(document.querySelector('input[name="playerCount"]:checked').value);
            const namesFromForm = [];
            for (let i = 0; i < currentNumPlayers; i++) {
                const playerInput = document.getElementById(`player${i + 1}`);
                namesFromForm.push(playerInput ? playerInput.value.trim() : "");
            }
             currentPlayerNamesOrder = namesFromForm.slice(0, currentNumPlayers);


            if (editingGameIndex !== -1) {
                allGamesData[editingGameIndex].inputs = gameInputs;
            } else {
                allGamesData.push({ id: gameInputs.id, inputs: gameInputs });
            }
            outputSection.style.display = 'block';
            recalculateAndRedrawTable();
            resetFormAndPrepareForNewGame(true);
            setNextDealerBasedOnLastGame();
            saveSessionToLocalStorage();
        });

        function recalculateAndRedrawTable() {
            outputTableBody.innerHTML = '';

            let tempBockActive = 0;
            let tempBockPlayedInStreak = 0;
            let tempBockTotalInStreak = 0;

            let currentCumulativeScores = {};
            const allPlayerNamesInSession = new Set();
            const currentNamesFromDOM = [];

            const numPlayersInForm = parseInt(document.querySelector('input[name="playerCount"]:checked').value);
            for (let i = 0; i < numPlayersInForm; i++) {
                const playerInput = document.getElementById(`player${i + 1}`);
                if (playerInput && playerInput.value.trim()) {
                    const pName = playerInput.value.trim();
                    allPlayerNamesInSession.add(pName);
                    currentNamesFromDOM.push(pName);
                }
            }

            allGamesData.forEach(gameEntry => {
                gameEntry.inputs.players.forEach(playerInput => {
                    if (playerInput.name && playerInput.name.trim()) {
                        allPlayerNamesInSession.add(playerInput.name.trim());
                    }
                });
            });

            allPlayerNamesInSession.forEach(name => {
                currentCumulativeScores[name] = 0;
            });

            updateOutputTableHeader();

            const plyNamesHead = [];
            const outputTableHeadCells = outputTable.querySelectorAll('thead tr th');
            for (let k = 3; k < outputTableHeadCells.length - 1; k++) {
                 if(outputTableHeadCells[k] && outputTableHeadCells[k].textContent) {
                    plyNamesHead.push(outputTableHeadCells[k].textContent);
                 }
            }
            allPlayerNamesInSession.forEach(sessionPlayerName => {
                if (!plyNamesHead.includes(sessionPlayerName)) {
                    plyNamesHead.push(sessionPlayerName);
                }
            });


            const chartLabels = ["Start"];
            const chartPlayerScoresData = {};
            plyNamesHead.forEach(name => { chartPlayerScoresData[name] = [0]; });


            for (let i = 0; i < allGamesData.length; i++) {
                const gameEntry = allGamesData[i]; const inputs = gameEntry.inputs; const gameDispNum = i + 1;
                const gamePlyCount = inputs.playerCount; const is5Ply = gamePlyCount === 5;
                const roles = { geber: null, re: [], h: null, solo: null }; const plyNamesConfThisGame = [];

                inputs.players.forEach(pIn => {
                    if (pIn.name && pIn.name.trim()) {
                        plyNamesConfThisGame.push(pIn.name.trim());
                    }
                    if (pIn.selectedRole === 're') roles.re.push(pIn.name.trim());
                    else if (pIn.selectedRole === 'hochzeit') roles.h = pIn.name.trim();
                    else if (pIn.selectedRole === 'solo') roles.solo = pIn.name.trim();
                    else if (pIn.selectedRole === 'geber') roles.geber = pIn.name.trim();
                });

                const activePlyInThisGame = plyNamesConfThisGame.filter(name => !(is5Ply && name === roles.geber));
                activePlyInThisGame.forEach(ap => { if (currentCumulativeScores[ap] === undefined) currentCumulativeScores[ap] = 0; });
                if (is5Ply && roles.geber && currentCumulativeScores[roles.geber] === undefined) {
                    currentCumulativeScores[roles.geber] = 0;
                }

                let gType = 'normal'; if (roles.solo && roles.solo.trim()) gType = 'solo'; else if (roles.h && roles.h.trim()) gType = 'hochzeit';
                const origVal = parseInt(inputs.gameValue);
                const isBockRoundCurrentGame = tempBockActive > 0;
                let bockDisp = "0/0";
                if (isBockRoundCurrentGame) {
                    bockDisp = `${tempBockPlayedInStreak + 1}/${tempBockTotalInStreak}`;
                }

                const addChartDataPointLocal = (labelSuffix = "") => {
                    let shortSuffix = labelSuffix.replace(/\s/g, '').replace('(', '').replace(')', '');
                    chartLabels.push(`${gameDispNum}${shortSuffix}`);
                    const scoresSnapshotForChart = { ...currentCumulativeScores };
                    plyNamesHead.forEach(playerNameInHeader => {
                        if (!chartPlayerScoresData[playerNameInHeader]) {
                             const lastVal = chartLabels.length > 2 && chartPlayerScoresData[playerNameInHeader] ? chartPlayerScoresData[playerNameInHeader][chartLabels.length - 2] : 0;
                             chartPlayerScoresData[playerNameInHeader] = Array(chartLabels.length -1).fill(lastVal);
                        }
                        chartPlayerScoresData[playerNameInHeader].push(
                            scoresSnapshotForChart[playerNameInHeader] !== undefined ? scoresSnapshotForChart[playerNameInHeader] :
                            (chartPlayerScoresData[playerNameInHeader] && chartPlayerScoresData[playerNameInHeader].length > 0 ? chartPlayerScoresData[playerNameInHeader][chartPlayerScoresData[playerNameInHeader].length -1] : 0)
                        );
                    });
                    const maxLen = chartLabels.length;
                    for(const pName in chartPlayerScoresData){
                        if(chartPlayerScoresData[pName]){
                            while(chartPlayerScoresData[pName].length < maxLen){
                                chartPlayerScoresData[pName].push(chartPlayerScoresData[pName][chartPlayerScoresData[pName].length-1]);
                            }
                        }
                    }
                };

                if (gType === 'hochzeit') {
                    const hPly = roles.h; const hPart = roles.re.length === 1 ? roles.re[0] : null; const valP1 = 1;
                    const effP1 = valP1 * (isBockRoundCurrentGame ? 2 : 1);
                    const scP1 = calculateSoloScores(hPly, activePlyInThisGame, effP1);
                    activePlyInThisGame.forEach(p => currentCumulativeScores[p] = (currentCumulativeScores[p] || 0) + (scP1[p] || 0));
                    const scoresSnapshotAfterPhase1 = { ...currentCumulativeScores };
                    addChartDataPointLocal(" (H1)");
                    let rostP1 = activePlyInThisGame.map(pn => ({ name: pn, roleForDisplay: (pn === hPly) ? 'hochzeit' : 'kontra' }));
                    if (is5Ply && roles.geber && !activePlyInThisGame.includes(roles.geber)) rostP1.push({ name: roles.geber, roleForDisplay: 'geber' });
                    addGameRowToTable(gameDispNum, i, `${effP1} (H Suche)`, bockDisp, plyNamesHead, rostP1, scoresSnapshotAfterPhase1,
                        { type: 'hochzeit_phase1', soloSpieler: hPly, geberName: roles.geber, isFivePlayerGame: is5Ply, activePlayersInThisRow: activePlyInThisGame, rePartei: null, triggeredBock: inputs.triggerNewBockRound });

                    const effP2 = origVal * (isBockRoundCurrentGame ? 2 : 1); let scP2 = {}; let rostP2Act = [];
                    let detP2 = { geberName: roles.geber, isFivePlayerGame: is5Ply, activePlayersInThisRow: activePlyInThisGame, triggeredBock: inputs.triggerNewBockRound };
                    if (hPart) {
                        scP2 = calculateReKontraScores([hPly, hPart], activePlyInThisGame, effP2); detP2.type = 'hochzeit_mit_partner'; detP2.rePartei = [hPly, hPart];
                        rostP2Act = activePlyInThisGame.map(pn => ({ name: pn, roleForDisplay: (pn === hPly) ? 'hochzeit' : (pn === hPart ? 're' : 'kontra') }));
                    } else {
                        scP2 = calculateSoloScores(hPly, activePlyInThisGame, effP2); detP2.type = 'hochzeit_solo'; detP2.soloSpieler = hPly;
                        rostP2Act = activePlyInThisGame.map(pn => ({ name: pn, roleForDisplay: (pn === hPly) ? 'hochzeit' : 'kontra' }));
                    }
                    activePlyInThisGame.forEach(p => currentCumulativeScores[p] = (currentCumulativeScores[p] || 0) + (scP2[p] || 0));
                    const scoresSnapshotAfterPhase2 = { ...currentCumulativeScores };
                    addChartDataPointLocal(" (H2)");
                    let fullRostP2 = [...rostP2Act]; if (is5Ply && roles.geber && !activePlyInThisGame.includes(roles.geber)) fullRostP2.push({ name: roles.geber, roleForDisplay: 'geber' });
                    addGameRowToTable(gameDispNum, i, `${effP2} (H ${hPart ? 'm.P.' : 'Solo'})`, bockDisp, plyNamesHead, fullRostP2, scoresSnapshotAfterPhase2, detP2);
                } else {
                    let rScores = {}; const effVal = origVal * (isBockRoundCurrentGame ? 2 : 1);
                    let dets = { geberName: roles.geber, isFivePlayerGame: is5Ply, activePlayersInThisRow: activePlyInThisGame, triggeredBock: inputs.triggerNewBockRound };
                    let rostAct = [];
                    if (gType === 'solo') {
                        rScores = calculateSoloScores(roles.solo, activePlyInThisGame, effVal); dets.type = 'solo'; dets.soloSpieler = roles.solo;
                        rostAct = activePlyInThisGame.map(pn => ({ name: pn, roleForDisplay: pn === roles.solo ? 'solo' : 'kontra' }));
                    } else {
                        rScores = calculateReKontraScores(roles.re, activePlyInThisGame, effVal); dets.type = 'normal'; dets.rePartei = roles.re;
                        rostAct = activePlyInThisGame.map(pn => ({ name: pn, roleForDisplay: roles.re.includes(pn) ? 're' : 'kontra' }));
                    }
                    activePlyInThisGame.forEach(p => currentCumulativeScores[p] = (currentCumulativeScores[p] || 0) + (rScores[p] || 0));
                    const scoresSnapshotAfterRound = { ...currentCumulativeScores };
                    addChartDataPointLocal();
                    let fullRost = [...rostAct]; if (is5Ply && roles.geber && !activePlyInThisGame.includes(roles.geber)) fullRost.push({ name: roles.geber, roleForDisplay: 'geber' });
                    addGameRowToTable(gameDispNum, i, effVal.toString(), bockDisp, plyNamesHead, fullRost, scoresSnapshotAfterRound, dets);
                }

                if (isBockRoundCurrentGame) {
                    tempBockActive--;
                    tempBockPlayedInStreak++;
                }
                const manTrigBock = inputs.triggerNewBockRound;
                const gamesForTrig = plyNamesConfThisGame.filter(n => n && n.trim()).length;
                let newBocks = 0;
                if (manTrigBock) newBocks += gamesForTrig;
                if (newBocks > 0) {
                    if (tempBockActive === 0) {
                        tempBockPlayedInStreak = 0;
                        tempBockTotalInStreak = newBocks;
                    } else {
                        tempBockTotalInStreak += newBocks;
                    }
                    tempBockActive += newBocks;
                }
                if (tempBockActive === 0 && tempBockPlayedInStreak >= tempBockTotalInStreak && tempBockTotalInStreak > 0) {
                    tempBockPlayedInStreak = 0; tempBockTotalInStreak = 0;
                }
                 gameEntry.stateAfterProcessing = {
                    cumulativeTotalScores: { ...currentCumulativeScores },
                    bockState: { active: tempBockActive, playedInStreak: tempBockPlayedInStreak, totalInStreak: tempBockTotalInStreak }
                };
            }

            if (allGamesData.length > 0) {
                const lastState = allGamesData[allGamesData.length - 1].stateAfterProcessing;
                totalScores = { ...lastState.cumulativeTotalScores };
                bockRoundsActive = lastState.bockState.active;
                bockGamesPlayedInCurrentStreak = lastState.bockState.playedInStreak;
                totalBockGamesInCurrentStreak = lastState.bockState.totalInStreak;
            } else {
                totalScores = {};
                allPlayerNamesInSession.forEach(name => {
                    totalScores[name] = currentCumulativeScores[name] || 0;
                });
                bockRoundsActive = 0; bockGamesPlayedInCurrentStreak = 0; totalBockGamesInCurrentStreak = 0;
            }

             if (outputTableBody.rows.length > 0) {
                outputSection.style.display = 'block';
             } else {
                outputSection.style.display = 'none';
            }

            displayAbrechnung();
            updateScoreChart(chartLabels, chartPlayerScoresData);
        }


        function startEditGame(gameIdx) {
            editingGameIndex = gameIdx;
            const gameToEdit = allGamesData[gameIdx].inputs;

            const pCountRad = document.getElementById(`players${gameToEdit.playerCount}`);
            if (pCountRad) pCountRad.checked = true;

            const playerNamesForEditForm = gameToEdit.players.map(p => ({name: p.name, selectedRole: p.selectedRole}));
            createPlayerColumns(gameToEdit.playerCount, playerNamesForEditForm);

            gameToEdit.players.forEach((pData, playerArrIndex) => {
                const domPlayerIndex = playerArrIndex + 1;
                document.querySelectorAll(`input[name="rolePlayer${domPlayerIndex}"]`).forEach(r => r.checked = false);
                if (pData.selectedRole) {
                    const roleRadSel = document.getElementById(`role${domPlayerIndex}-${pData.selectedRole}`);
                    if (roleRadSel) roleRadSel.checked = true;
                }
            });
             currentPlayerNamesOrder = gameToEdit.players.map(p => p.name.trim()).slice(0, gameToEdit.playerCount);


            gameValueRadios.forEach(r => r.checked = false);
            customGameValueInput.value = '';
            const valStr = gameToEdit.gameValue.toString();
            const valRad = document.querySelector(`input[name="gameValueRadio"][value="${valStr}"]`);
            if (valRad) valRad.checked = true;
            else customGameValueInput.value = valStr;

            document.getElementById('triggerNewBockRound').checked = gameToEdit.triggerNewBockRound;

            const geberData = gameToEdit.players.find(p => p.selectedRole === 'geber');
            currentDealerIndex = -1;
            if (geberData && geberData.name) {
                for(let i=0; i < gameToEdit.playerCount; i++){
                    const nameField = document.getElementById(`player${i+1}`);
                    if(nameField && nameField.value.trim() === geberData.name){
                        currentDealerIndex = i;
                        const geberRadioToSelect = document.getElementById(`role${i + 1}-geber`);
                        if(geberRadioToSelect) geberRadioToSelect.checked = true; else console.warn("Geber Radio nicht gefunden für", `role${i + 1}-geber`);
                        break;
                    }
                }
            }


            submitGameButton.textContent = 'Änderungen speichern';
            submitGameButton.style.backgroundColor = '#ffc107';
            document.querySelector('.input-section').scrollIntoView({ behavior: "smooth" });
            updateOutputTableHeader();
            validateRoles();
        }

        function saveSessionToLocalStorage() {
            const currentNumPlayers = parseInt(document.querySelector('input[name="playerCount"]:checked').value);
            const namesFromFormForSave = [];
            for (let i = 0; i < currentNumPlayers; i++) {
                const playerInput = document.getElementById(`player${i + 1}`);
                namesFromFormForSave.push(playerInput ? playerInput.value.trim() : "");
            }
            currentPlayerNamesOrder = namesFromFormForSave.slice(0, currentNumPlayers);


            const sessionData = {
                allGamesData,
                currentPlayerNamesOrder: currentPlayerNamesOrder,
                currentDealerIndex,
                selectedPlayerCount: currentNumPlayers,
                startgeld: startgeldInput.value,
                punktwert: punktwertInput.value
            };
            localStorage.setItem(DOKO_STORAGE_KEY, JSON.stringify(sessionData));
        }

        function loadSessionFromLocalStorage() {
            const stored = localStorage.getItem(DOKO_STORAGE_KEY);
            if (stored) {
                const data = JSON.parse(stored);
                allGamesData = data.allGamesData || [];
                currentPlayerNamesOrder = data.currentPlayerNamesOrder || Array(data.selectedPlayerCount || 5).fill("");
                currentDealerIndex = data.currentDealerIndex !== undefined ? data.currentDealerIndex : -1;
                startgeldInput.value = data.startgeld !== undefined ? data.startgeld : "10.00";
                punktwertInput.value = data.punktwert !== undefined ? data.punktwert : "0.05";

                const pCountSet = data.selectedPlayerCount || 5;
                const pCountRadSet = document.getElementById(`players${pCountSet}`);
                if (pCountRadSet) pCountRadSet.checked = true;

                createPlayerColumns(pCountSet, null);


                if (allGamesData.length > 0) {
                    recalculateAndRedrawTable();
                     outputSection.style.display = 'block';
                } else {
                    updateOutputTableHeader();
                    totalScores = {};
                    currentPlayerNamesOrder.forEach(n => { if (n && n.trim()) totalScores[n.trim()] = 0; });
                    bockRoundsActive = 0; bockGamesPlayedInCurrentStreak = 0; totalBockGamesInCurrentStreak = 0;
                    displayAbrechnung();
                    const initialChartScores = {};
                    currentPlayerNamesOrder.forEach(n => { if (n && n.trim()) initialChartScores[n] = [0]; });
                    updateScoreChart(["Start"], initialChartScores);

                    outputSection.style.display = 'none';
                }
                if (allGamesData.length > 0) {
                    setNextDealerBasedOnLastGame();
                } else if (currentDealerIndex !== -1 && currentDealerIndex < currentPlayerNamesOrder.length && currentPlayerNamesOrder[currentDealerIndex]) {
                    const geberRadioToSelect = document.getElementById(`role${currentDealerIndex + 1}-geber`);
                    if(geberRadioToSelect && document.getElementById(`player${currentDealerIndex+1}`).value === currentPlayerNamesOrder[currentDealerIndex]) {
                         geberRadioToSelect.checked = true;
                    } else {
                        setNextDealerAutomatically();
                    }
                } else {
                    setNextDealerAutomatically();
                }


            } else {
                const initPlyCount = parseInt(document.querySelector('input[name="playerCount"]:checked').value);
                currentPlayerNamesOrder = Array(initPlyCount).fill("");
                createPlayerColumns(initPlyCount);
                updateOutputTableHeader();
                totalScores = {};
                bockRoundsActive = 0; bockGamesPlayedInCurrentStreak = 0; totalBockGamesInCurrentStreak = 0;
                startgeldInput.value = "10.00";
                punktwertInput.value = "0.05";
                displayAbrechnung();
                updateScoreChart(["Start"], {});
                setNextDealerAutomatically();
                outputSection.style.display = 'none';
            }
            validateRoles();
        }

        function setNextDealerBasedOnLastGame() {
            if (allGamesData.length > 0 && allGamesData[allGamesData.length - 1].inputs) {
                const lastInputs = allGamesData[allGamesData.length - 1].inputs;
                const lastDealerData = lastInputs.players.find(p => p.selectedRole === 'geber');
                if (lastDealerData && lastDealerData.name) {
                    setNextDealerAutomatically(lastDealerData.name);
                } else {
                    setNextDealerAutomatically();
                }
            } else {
                 if (currentDealerIndex !== -1 && currentDealerIndex < currentPlayerNamesOrder.length && currentPlayerNamesOrder[currentDealerIndex] && currentPlayerNamesOrder[currentDealerIndex].trim() !== '') {
                    const dealerNameFromOrder = currentPlayerNamesOrder[currentDealerIndex];
                    let nameInDom = false;
                    const numPlayersInForm = parseInt(document.querySelector('input[name="playerCount"]:checked').value);
                    for(let i=0; i<numPlayersInForm; i++){
                        const inputField = document.getElementById(`player${i+1}`);
                        if(inputField && inputField.value.trim() === dealerNameFromOrder){
                            nameInDom = true;
                            currentDealerIndex = i;
                            const dealerRadio = document.getElementById(`role${currentDealerIndex + 1}-geber`);
                            if (dealerRadio) dealerRadio.checked = true;
                            break;
                        }
                    }
                    if(!nameInDom) setNextDealerAutomatically();
                } else {
                    setNextDealerAutomatically();
                }
            }
        }

        function startNewGameDay() {
            const conf = confirm("Möchten Sie wirklich alle Daten löschen und einen neuen Spieltag beginnen?\nDieser Vorgang kann nicht rückgängig gemacht werden.");
            if (conf) { localStorage.removeItem(DOKO_STORAGE_KEY); location.reload(); }
        }

        function displayAbrechnung() {
            if (!startgeldInput || !punktwertInput || !abrechnungTable || !abrechnungOutputDiv) return;
            const startgeld = parseFloat(startgeldInput.value) || 0;
            const punktwertVal = parseFloat(punktwertInput.value) || 0;

            let activePlyNamesForAbrechnung = [];
            if(Object.keys(totalScores).length > 0){
                activePlyNamesForAbrechnung = Object.keys(totalScores).filter(name => totalScores[name] !== undefined && name.trim() !== "");
            }

            if(activePlyNamesForAbrechnung.length === 0) { // Fallback, wenn totalScores noch leer ist
                const numPlyInForm = parseInt(document.querySelector('input[name="playerCount"]:checked').value);
                 for (let i=0; i < numPlyInForm; i++) {
                    const playerInput = document.getElementById(`player${i+1}`);
                    if (playerInput && playerInput.value.trim()) {
                        activePlyNamesForAbrechnung.push(playerInput.value.trim());
                    }
                 }
            }
            activePlyNamesForAbrechnung = activePlyNamesForAbrechnung.filter(name => name && name.trim() !== "");


            activePlyNamesForAbrechnung.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

            if (activePlyNamesForAbrechnung.length === 0) {
                abrechnungOutputDiv.style.display = 'none'; return;
            }

            let maxScr = -Infinity;
            activePlyNamesForAbrechnung.forEach(n => {
                const score = totalScores[n] || 0;
                if (score > maxScr) maxScr = score;
            });
             if (maxScr === -Infinity && activePlyNamesForAbrechnung.length > 0) maxScr = 0;


            const tblHead = abrechnungTable.querySelector('thead');
            const tblBody = abrechnungTable.querySelector('tbody');
            tblHead.innerHTML = ''; tblBody.innerHTML = '';

            const headRw = tblHead.insertRow();
            const thBez = document.createElement('th');
            thBez.textContent = 'Position';
            thBez.style.textAlign = 'left';
            headRw.appendChild(thBez);

            activePlyNamesForAbrechnung.forEach(n => {
                const th = document.createElement('th');
                th.textContent = n;
                th.style.textAlign = 'right';
                headRw.appendChild(th);
            });

            const pkteRw = tblBody.insertRow();
            pkteRw.insertCell().textContent = 'Endpunkte';
            activePlyNamesForAbrechnung.forEach(n => {
                const c = pkteRw.insertCell();
                c.textContent = totalScores[n] !== undefined ? totalScores[n].toString() : '0';
                c.style.textAlign = 'right';
            });

            const zuZahlRw = tblBody.insertRow();
            zuZahlRw.insertCell().textContent = 'Zu Zahlen (€)';
            activePlyNamesForAbrechnung.forEach(n => {
                const c = zuZahlRw.insertCell();
                const curScr = totalScores[n] !== undefined ? totalScores[n] : 0;
                let betrag = 0; // Intern wird der zu zahlende Betrag als negativer Wert für die Logik berechnet

                if (curScr === maxScr) {
                    betrag = -startgeld; // Zahlt Startgeld
                } else {
                    betrag = -(((maxScr - curScr) * punktwertVal) + startgeld); // Zahlt Startgeld + Differenz
                }

                c.textContent = Math.abs(betrag).toFixed(2) + " €"; // Anzeige als positiver Wert
                c.style.textAlign = 'right';
                // Klasse "negative-score" wird hier nicht mehr gesetzt, da der Wert positiv angezeigt wird.
            });
            abrechnungOutputDiv.style.display = 'block';
        }


        function updateScoreChart(chartLabels, chartPlayerScoresData) {
            if (!scoreChartCanvas) return; const ctx = scoreChartCanvas.getContext('2d');
            if (myScoreChart) myScoreChart.destroy(); myScoreChart = null;
            const playerColors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#2E8B57', '#DAA520']; let cIdx = 0;
            const datasets = [];

            let activePlyForChart = [];
             if(Object.keys(chartPlayerScoresData).length > 0 && Object.keys(chartPlayerScoresData).some(key => chartPlayerScoresData[key] && chartPlayerScoresData[key].length > 0)){
                 activePlyForChart = Object.keys(chartPlayerScoresData).filter(key => chartPlayerScoresData[key] && chartPlayerScoresData[key].length > 0 && key.trim() !== "");
             } else if (Object.keys(totalScores).length > 0){
                 activePlyForChart = Object.keys(totalScores).filter(name => totalScores[name] !== undefined && name.trim() !== "");
             } else {
                const numPlySel = parseInt(document.querySelector('input[name="playerCount"]:checked').value);
                 for (let i = 0; i < numPlySel; i++) {
                    const playerInput = document.getElementById(`player${i + 1}`);
                    if (playerInput && playerInput.value.trim()) {
                        activePlyForChart.push(playerInput.value.trim());
                    }
                 }
            }
            activePlyForChart = activePlyForChart.filter(name => name && name.trim() !== "");


            activePlyForChart.forEach(pN => {
                if (chartPlayerScoresData[pN] && chartPlayerScoresData[pN].length > 0) {
                    datasets.push({ label: pN, data: chartPlayerScoresData[pN], borderColor: playerColors[cIdx % playerColors.length], backgroundColor: playerColors[cIdx % playerColors.length], fill: false, tension: 0.1, pointRadius: 3, pointHoverRadius: 5 });
                    cIdx++;
                } else if (chartLabels.length === 1 && chartLabels[0] === "Start" && activePlyForChart.includes(pN)) {
                    const initialData = [0];
                     datasets.push({ label: pN, data: initialData, borderColor: playerColors[cIdx % playerColors.length], backgroundColor: playerColors[cIdx % playerColors.length], fill: false, tension: 0.1, pointRadius: 3, pointHoverRadius: 5 });
                    cIdx++;
                }
            });

            let hasMeaningfulData = false;
            if (datasets.some(ds => ds.data && ds.data.length > 0)) { // Zeige Chart, wenn überhaupt Daten vorhanden sind
                hasMeaningfulData = true;
            }


            if (!hasMeaningfulData || datasets.length === 0) {
                 if(ctx) ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                 if(chartSectionDiv) chartSectionDiv.style.display = 'none';
                 return;
            }


            if(chartSectionDiv) chartSectionDiv.style.display = 'block';
            myScoreChart = new Chart(ctx, {
                type: 'line', data: { labels: chartLabels, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { position: 'top' }, title: { display: true, text: 'Kumulativer Punkteverlauf' }},
                    scales: {
                        x: {
                            title: { display: true, text: 'Spiel/Phase' },
                            ticks: {
                                autoSkip: true,
                                maxRotation: 45,
                                minRotation: 0,
                                maxTicksLimit: 20 // Hier kann experimentiert werden (z.B. 15, 25)
                            }
                        },
                        y: {
                            title: { display: true, text: 'Kumulierte Punkte' },
                            beginAtZero: false
                        }
                    }
                }
            });
        }

        playerCountRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                const newCount = parseInt(event.target.value);
                const currentNamesInFields = [];
                const currentRoles = [];

                const oldPlayerColumns = playerRoleRow.querySelectorAll('.player-column');
                oldPlayerColumns.forEach((col, idx) => {
                    const nameInput = col.querySelector(`input[id="player${idx+1}"]`);
                    if (nameInput) currentNamesInFields.push(nameInput.value.trim()); else currentNamesInFields.push("");

                    const roleRadio = col.querySelector(`input[name="rolePlayer${idx+1}"]:checked`);
                    if (roleRadio) currentRoles.push({playerIndex: idx, role: roleRadio.value});
                });


                currentPlayerNamesOrder = currentNamesInFields.slice(0, newCount);
                while(currentPlayerNamesOrder.length < newCount) currentPlayerNamesOrder.push("");


                createPlayerColumns(newCount);

                let geberNeuGesetzt = false;
                currentRoles.forEach(roleInfo => {
                    if (roleInfo && roleInfo.playerIndex < newCount) {
                        const alterNameAnPosition = currentNamesInFields[roleInfo.playerIndex];
                        const neuerNameAnPositionImForm = document.getElementById(`player${roleInfo.playerIndex + 1}`)?.value.trim();

                        if (alterNameAnPosition && neuerNameAnPositionImForm === alterNameAnPosition) {
                             const roleRadioToSelect = document.getElementById(`role${roleInfo.playerIndex + 1}-${roleInfo.role}`);
                             if (roleRadioToSelect) {
                                 roleRadioToSelect.checked = true;
                                 if(roleInfo.role === 'geber') {
                                     currentDealerIndex = roleInfo.playerIndex;
                                     geberNeuGesetzt = true;
                                 }
                             }
                        }
                    }
                });

                if(!geberNeuGesetzt){
                    setNextDealerAutomatically();
                } else {
                     validateRoles();
                }


                if (allGamesData.length === 0) {
                    totalScores = {};
                    const namesInNewForm = [];
                    for(let i=0; i < newCount; i++){
                        const input = document.getElementById(`player${i+1}`);
                        if(input && input.value.trim()){
                             namesInNewForm.push(input.value.trim());
                             totalScores[input.value.trim()] = 0;
                        }
                    }
                    displayAbrechnung();
                    const initialChartPlayerScores = {};
                    namesInNewForm.forEach(n => { initialChartPlayerScores[n] = [0];});
                    updateScoreChart(["Start"], initialChartPlayerScores);
                } else {
                    recalculateAndRedrawTable();
                }
            });
        });


        document.addEventListener('DOMContentLoaded', () => {
            const outputTableHeadRow = outputTable.querySelector('thead tr');
            if (outputTableHeadRow && outputTableHeadRow.children.length === 0) {
                outputTableHeadRow.insertCell().textContent = 'Spiel #';
                outputTableHeadRow.insertCell().textContent = 'Spielwert';
                outputTableHeadRow.insertCell().textContent = 'Bock';
            }

            displayCurrentDate();
            loadSessionFromLocalStorage();
            if (newGameDayButton) newGameDayButton.addEventListener('click', startNewGameDay);
            if (startgeldInput) {
                startgeldInput.addEventListener('input', () => { displayAbrechnung(); saveSessionToLocalStorage(); });
            }
            if (punktwertInput) {
                punktwertInput.addEventListener('input', () => { displayAbrechnung(); saveSessionToLocalStorage(); });
            }
        });
    </script>
</body>
</html>